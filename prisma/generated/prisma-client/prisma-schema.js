module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCloser {
  count: Int!
}

type AggregatePeople {
  count: Int!
}

type AggregateReport {
  count: Int!
}

type AggregateReportComment {
  count: Int!
}

type AggregateReportType {
  count: Int!
}

type AggregateRole {
  count: Int!
}

type AggregateStatus {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Closer {
  id: ID!
  image: String!
  user: User!
  report: Report!
  createdAt: DateTime!
}

type CloserConnection {
  pageInfo: PageInfo!
  edges: [CloserEdge]!
  aggregate: AggregateCloser!
}

input CloserCreateInput {
  id: ID
  image: String!
  user: UserCreateOneWithoutClosedReportsInput!
  report: ReportCreateOneWithoutCloserInput!
}

input CloserCreateManyWithoutUserInput {
  create: [CloserCreateWithoutUserInput!]
  connect: [CloserWhereUniqueInput!]
}

input CloserCreateOneWithoutReportInput {
  create: CloserCreateWithoutReportInput
  connect: CloserWhereUniqueInput
}

input CloserCreateWithoutReportInput {
  id: ID
  image: String!
  user: UserCreateOneWithoutClosedReportsInput!
}

input CloserCreateWithoutUserInput {
  id: ID
  image: String!
  report: ReportCreateOneWithoutCloserInput!
}

type CloserEdge {
  node: Closer!
  cursor: String!
}

enum CloserOrderByInput {
  id_ASC
  id_DESC
  image_ASC
  image_DESC
  createdAt_ASC
  createdAt_DESC
}

type CloserPreviousValues {
  id: ID!
  image: String!
  createdAt: DateTime!
}

input CloserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CloserScalarWhereInput!]
  OR: [CloserScalarWhereInput!]
  NOT: [CloserScalarWhereInput!]
}

type CloserSubscriptionPayload {
  mutation: MutationType!
  node: Closer
  updatedFields: [String!]
  previousValues: CloserPreviousValues
}

input CloserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CloserWhereInput
  AND: [CloserSubscriptionWhereInput!]
  OR: [CloserSubscriptionWhereInput!]
  NOT: [CloserSubscriptionWhereInput!]
}

input CloserUpdateInput {
  image: String
  user: UserUpdateOneRequiredWithoutClosedReportsInput
  report: ReportUpdateOneRequiredWithoutCloserInput
}

input CloserUpdateManyDataInput {
  image: String
}

input CloserUpdateManyMutationInput {
  image: String
}

input CloserUpdateManyWithoutUserInput {
  create: [CloserCreateWithoutUserInput!]
  delete: [CloserWhereUniqueInput!]
  connect: [CloserWhereUniqueInput!]
  set: [CloserWhereUniqueInput!]
  disconnect: [CloserWhereUniqueInput!]
  update: [CloserUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [CloserUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [CloserScalarWhereInput!]
  updateMany: [CloserUpdateManyWithWhereNestedInput!]
}

input CloserUpdateManyWithWhereNestedInput {
  where: CloserScalarWhereInput!
  data: CloserUpdateManyDataInput!
}

input CloserUpdateOneWithoutReportInput {
  create: CloserCreateWithoutReportInput
  update: CloserUpdateWithoutReportDataInput
  upsert: CloserUpsertWithoutReportInput
  delete: Boolean
  disconnect: Boolean
  connect: CloserWhereUniqueInput
}

input CloserUpdateWithoutReportDataInput {
  image: String
  user: UserUpdateOneRequiredWithoutClosedReportsInput
}

input CloserUpdateWithoutUserDataInput {
  image: String
  report: ReportUpdateOneRequiredWithoutCloserInput
}

input CloserUpdateWithWhereUniqueWithoutUserInput {
  where: CloserWhereUniqueInput!
  data: CloserUpdateWithoutUserDataInput!
}

input CloserUpsertWithoutReportInput {
  update: CloserUpdateWithoutReportDataInput!
  create: CloserCreateWithoutReportInput!
}

input CloserUpsertWithWhereUniqueWithoutUserInput {
  where: CloserWhereUniqueInput!
  update: CloserUpdateWithoutUserDataInput!
  create: CloserCreateWithoutUserInput!
}

input CloserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  user: UserWhereInput
  report: ReportWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CloserWhereInput!]
  OR: [CloserWhereInput!]
  NOT: [CloserWhereInput!]
}

input CloserWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Mutation {
  createCloser(data: CloserCreateInput!): Closer!
  updateCloser(data: CloserUpdateInput!, where: CloserWhereUniqueInput!): Closer
  updateManyClosers(data: CloserUpdateManyMutationInput!, where: CloserWhereInput): BatchPayload!
  upsertCloser(where: CloserWhereUniqueInput!, create: CloserCreateInput!, update: CloserUpdateInput!): Closer!
  deleteCloser(where: CloserWhereUniqueInput!): Closer
  deleteManyClosers(where: CloserWhereInput): BatchPayload!
  createPeople(data: PeopleCreateInput!): People!
  updatePeople(data: PeopleUpdateInput!, where: PeopleWhereUniqueInput!): People
  updateManyPeoples(data: PeopleUpdateManyMutationInput!, where: PeopleWhereInput): BatchPayload!
  upsertPeople(where: PeopleWhereUniqueInput!, create: PeopleCreateInput!, update: PeopleUpdateInput!): People!
  deletePeople(where: PeopleWhereUniqueInput!): People
  deleteManyPeoples(where: PeopleWhereInput): BatchPayload!
  createReport(data: ReportCreateInput!): Report!
  updateReport(data: ReportUpdateInput!, where: ReportWhereUniqueInput!): Report
  updateManyReports(data: ReportUpdateManyMutationInput!, where: ReportWhereInput): BatchPayload!
  upsertReport(where: ReportWhereUniqueInput!, create: ReportCreateInput!, update: ReportUpdateInput!): Report!
  deleteReport(where: ReportWhereUniqueInput!): Report
  deleteManyReports(where: ReportWhereInput): BatchPayload!
  createReportComment(data: ReportCommentCreateInput!): ReportComment!
  updateReportComment(data: ReportCommentUpdateInput!, where: ReportCommentWhereUniqueInput!): ReportComment
  updateManyReportComments(data: ReportCommentUpdateManyMutationInput!, where: ReportCommentWhereInput): BatchPayload!
  upsertReportComment(where: ReportCommentWhereUniqueInput!, create: ReportCommentCreateInput!, update: ReportCommentUpdateInput!): ReportComment!
  deleteReportComment(where: ReportCommentWhereUniqueInput!): ReportComment
  deleteManyReportComments(where: ReportCommentWhereInput): BatchPayload!
  createReportType(data: ReportTypeCreateInput!): ReportType!
  updateReportType(data: ReportTypeUpdateInput!, where: ReportTypeWhereUniqueInput!): ReportType
  updateManyReportTypes(data: ReportTypeUpdateManyMutationInput!, where: ReportTypeWhereInput): BatchPayload!
  upsertReportType(where: ReportTypeWhereUniqueInput!, create: ReportTypeCreateInput!, update: ReportTypeUpdateInput!): ReportType!
  deleteReportType(where: ReportTypeWhereUniqueInput!): ReportType
  deleteManyReportTypes(where: ReportTypeWhereInput): BatchPayload!
  createRole(data: RoleCreateInput!): Role!
  updateRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
  updateManyRoles(data: RoleUpdateManyMutationInput!, where: RoleWhereInput): BatchPayload!
  upsertRole(where: RoleWhereUniqueInput!, create: RoleCreateInput!, update: RoleUpdateInput!): Role!
  deleteRole(where: RoleWhereUniqueInput!): Role
  deleteManyRoles(where: RoleWhereInput): BatchPayload!
  createStatus(data: StatusCreateInput!): Status!
  updateStatus(data: StatusUpdateInput!, where: StatusWhereUniqueInput!): Status
  updateManyStatuses(data: StatusUpdateManyMutationInput!, where: StatusWhereInput): BatchPayload!
  upsertStatus(where: StatusWhereUniqueInput!, create: StatusCreateInput!, update: StatusUpdateInput!): Status!
  deleteStatus(where: StatusWhereUniqueInput!): Status
  deleteManyStatuses(where: StatusWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type People {
  id: ID!
  name: String!
  surname: String!
  street: String!
  address: String!
  home: String!
  phone: String!
  password: String!
  image: String!
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report!]
}

type PeopleConnection {
  pageInfo: PageInfo!
  edges: [PeopleEdge]!
  aggregate: AggregatePeople!
}

input PeopleCreateInput {
  id: ID
  name: String!
  surname: String!
  street: String!
  address: String!
  home: String!
  phone: String!
  password: String!
  image: String!
  reports: ReportCreateManyWithoutCreatorInput
}

input PeopleCreateOneWithoutReportsInput {
  create: PeopleCreateWithoutReportsInput
  connect: PeopleWhereUniqueInput
}

input PeopleCreateWithoutReportsInput {
  id: ID
  name: String!
  surname: String!
  street: String!
  address: String!
  home: String!
  phone: String!
  password: String!
  image: String!
}

type PeopleEdge {
  node: People!
  cursor: String!
}

enum PeopleOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  surname_ASC
  surname_DESC
  street_ASC
  street_DESC
  address_ASC
  address_DESC
  home_ASC
  home_DESC
  phone_ASC
  phone_DESC
  password_ASC
  password_DESC
  image_ASC
  image_DESC
}

type PeoplePreviousValues {
  id: ID!
  name: String!
  surname: String!
  street: String!
  address: String!
  home: String!
  phone: String!
  password: String!
  image: String!
}

type PeopleSubscriptionPayload {
  mutation: MutationType!
  node: People
  updatedFields: [String!]
  previousValues: PeoplePreviousValues
}

input PeopleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PeopleWhereInput
  AND: [PeopleSubscriptionWhereInput!]
  OR: [PeopleSubscriptionWhereInput!]
  NOT: [PeopleSubscriptionWhereInput!]
}

input PeopleUpdateInput {
  name: String
  surname: String
  street: String
  address: String
  home: String
  phone: String
  password: String
  image: String
  reports: ReportUpdateManyWithoutCreatorInput
}

input PeopleUpdateManyMutationInput {
  name: String
  surname: String
  street: String
  address: String
  home: String
  phone: String
  password: String
  image: String
}

input PeopleUpdateOneRequiredWithoutReportsInput {
  create: PeopleCreateWithoutReportsInput
  update: PeopleUpdateWithoutReportsDataInput
  upsert: PeopleUpsertWithoutReportsInput
  connect: PeopleWhereUniqueInput
}

input PeopleUpdateWithoutReportsDataInput {
  name: String
  surname: String
  street: String
  address: String
  home: String
  phone: String
  password: String
  image: String
}

input PeopleUpsertWithoutReportsInput {
  update: PeopleUpdateWithoutReportsDataInput!
  create: PeopleCreateWithoutReportsInput!
}

input PeopleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  surname: String
  surname_not: String
  surname_in: [String!]
  surname_not_in: [String!]
  surname_lt: String
  surname_lte: String
  surname_gt: String
  surname_gte: String
  surname_contains: String
  surname_not_contains: String
  surname_starts_with: String
  surname_not_starts_with: String
  surname_ends_with: String
  surname_not_ends_with: String
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  home: String
  home_not: String
  home_in: [String!]
  home_not_in: [String!]
  home_lt: String
  home_lte: String
  home_gt: String
  home_gte: String
  home_contains: String
  home_not_contains: String
  home_starts_with: String
  home_not_starts_with: String
  home_ends_with: String
  home_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  reports_every: ReportWhereInput
  reports_some: ReportWhereInput
  reports_none: ReportWhereInput
  AND: [PeopleWhereInput!]
  OR: [PeopleWhereInput!]
  NOT: [PeopleWhereInput!]
}

input PeopleWhereUniqueInput {
  id: ID
  phone: String
}

type Query {
  closer(where: CloserWhereUniqueInput!): Closer
  closers(where: CloserWhereInput, orderBy: CloserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Closer]!
  closersConnection(where: CloserWhereInput, orderBy: CloserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CloserConnection!
  people(where: PeopleWhereUniqueInput!): People
  peoples(where: PeopleWhereInput, orderBy: PeopleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [People]!
  peoplesConnection(where: PeopleWhereInput, orderBy: PeopleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PeopleConnection!
  report(where: ReportWhereUniqueInput!): Report
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report]!
  reportsConnection(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportConnection!
  reportComment(where: ReportCommentWhereUniqueInput!): ReportComment
  reportComments(where: ReportCommentWhereInput, orderBy: ReportCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ReportComment]!
  reportCommentsConnection(where: ReportCommentWhereInput, orderBy: ReportCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportCommentConnection!
  reportType(where: ReportTypeWhereUniqueInput!): ReportType
  reportTypes(where: ReportTypeWhereInput, orderBy: ReportTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ReportType]!
  reportTypesConnection(where: ReportTypeWhereInput, orderBy: ReportTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportTypeConnection!
  role(where: RoleWhereUniqueInput!): Role
  roles(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Role]!
  rolesConnection(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoleConnection!
  status(where: StatusWhereUniqueInput!): Status
  statuses(where: StatusWhereInput, orderBy: StatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Status]!
  statusesConnection(where: StatusWhereInput, orderBy: StatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StatusConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Report {
  id: Int!
  image: String!
  lat: Float!
  lng: Float!
  creator: People!
  closer: Closer
  comments(where: ReportCommentWhereInput, orderBy: ReportCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ReportComment!]
  status: Status!
  type: ReportType!
  deadline: DateTime
  createdAt: DateTime!
}

type ReportComment {
  id: ID!
  comment: String
  status: Status!
  report: Report!
  to: User!
  createdAt: DateTime!
}

type ReportCommentConnection {
  pageInfo: PageInfo!
  edges: [ReportCommentEdge]!
  aggregate: AggregateReportComment!
}

input ReportCommentCreateInput {
  id: ID
  comment: String
  status: StatusCreateOneInput!
  report: ReportCreateOneWithoutCommentsInput!
  to: UserCreateOneWithoutReportsInput!
}

input ReportCommentCreateManyWithoutReportInput {
  create: [ReportCommentCreateWithoutReportInput!]
  connect: [ReportCommentWhereUniqueInput!]
}

input ReportCommentCreateManyWithoutToInput {
  create: [ReportCommentCreateWithoutToInput!]
  connect: [ReportCommentWhereUniqueInput!]
}

input ReportCommentCreateWithoutReportInput {
  id: ID
  comment: String
  status: StatusCreateOneInput!
  to: UserCreateOneWithoutReportsInput!
}

input ReportCommentCreateWithoutToInput {
  id: ID
  comment: String
  status: StatusCreateOneInput!
  report: ReportCreateOneWithoutCommentsInput!
}

type ReportCommentEdge {
  node: ReportComment!
  cursor: String!
}

enum ReportCommentOrderByInput {
  id_ASC
  id_DESC
  comment_ASC
  comment_DESC
  createdAt_ASC
  createdAt_DESC
}

type ReportCommentPreviousValues {
  id: ID!
  comment: String
  createdAt: DateTime!
}

input ReportCommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ReportCommentScalarWhereInput!]
  OR: [ReportCommentScalarWhereInput!]
  NOT: [ReportCommentScalarWhereInput!]
}

type ReportCommentSubscriptionPayload {
  mutation: MutationType!
  node: ReportComment
  updatedFields: [String!]
  previousValues: ReportCommentPreviousValues
}

input ReportCommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportCommentWhereInput
  AND: [ReportCommentSubscriptionWhereInput!]
  OR: [ReportCommentSubscriptionWhereInput!]
  NOT: [ReportCommentSubscriptionWhereInput!]
}

input ReportCommentUpdateInput {
  comment: String
  status: StatusUpdateOneRequiredInput
  report: ReportUpdateOneRequiredWithoutCommentsInput
  to: UserUpdateOneRequiredWithoutReportsInput
}

input ReportCommentUpdateManyDataInput {
  comment: String
}

input ReportCommentUpdateManyMutationInput {
  comment: String
}

input ReportCommentUpdateManyWithoutReportInput {
  create: [ReportCommentCreateWithoutReportInput!]
  delete: [ReportCommentWhereUniqueInput!]
  connect: [ReportCommentWhereUniqueInput!]
  set: [ReportCommentWhereUniqueInput!]
  disconnect: [ReportCommentWhereUniqueInput!]
  update: [ReportCommentUpdateWithWhereUniqueWithoutReportInput!]
  upsert: [ReportCommentUpsertWithWhereUniqueWithoutReportInput!]
  deleteMany: [ReportCommentScalarWhereInput!]
  updateMany: [ReportCommentUpdateManyWithWhereNestedInput!]
}

input ReportCommentUpdateManyWithoutToInput {
  create: [ReportCommentCreateWithoutToInput!]
  delete: [ReportCommentWhereUniqueInput!]
  connect: [ReportCommentWhereUniqueInput!]
  set: [ReportCommentWhereUniqueInput!]
  disconnect: [ReportCommentWhereUniqueInput!]
  update: [ReportCommentUpdateWithWhereUniqueWithoutToInput!]
  upsert: [ReportCommentUpsertWithWhereUniqueWithoutToInput!]
  deleteMany: [ReportCommentScalarWhereInput!]
  updateMany: [ReportCommentUpdateManyWithWhereNestedInput!]
}

input ReportCommentUpdateManyWithWhereNestedInput {
  where: ReportCommentScalarWhereInput!
  data: ReportCommentUpdateManyDataInput!
}

input ReportCommentUpdateWithoutReportDataInput {
  comment: String
  status: StatusUpdateOneRequiredInput
  to: UserUpdateOneRequiredWithoutReportsInput
}

input ReportCommentUpdateWithoutToDataInput {
  comment: String
  status: StatusUpdateOneRequiredInput
  report: ReportUpdateOneRequiredWithoutCommentsInput
}

input ReportCommentUpdateWithWhereUniqueWithoutReportInput {
  where: ReportCommentWhereUniqueInput!
  data: ReportCommentUpdateWithoutReportDataInput!
}

input ReportCommentUpdateWithWhereUniqueWithoutToInput {
  where: ReportCommentWhereUniqueInput!
  data: ReportCommentUpdateWithoutToDataInput!
}

input ReportCommentUpsertWithWhereUniqueWithoutReportInput {
  where: ReportCommentWhereUniqueInput!
  update: ReportCommentUpdateWithoutReportDataInput!
  create: ReportCommentCreateWithoutReportInput!
}

input ReportCommentUpsertWithWhereUniqueWithoutToInput {
  where: ReportCommentWhereUniqueInput!
  update: ReportCommentUpdateWithoutToDataInput!
  create: ReportCommentCreateWithoutToInput!
}

input ReportCommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  status: StatusWhereInput
  report: ReportWhereInput
  to: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ReportCommentWhereInput!]
  OR: [ReportCommentWhereInput!]
  NOT: [ReportCommentWhereInput!]
}

input ReportCommentWhereUniqueInput {
  id: ID
}

type ReportConnection {
  pageInfo: PageInfo!
  edges: [ReportEdge]!
  aggregate: AggregateReport!
}

input ReportCreateInput {
  image: String!
  lat: Float!
  lng: Float!
  creator: PeopleCreateOneWithoutReportsInput!
  closer: CloserCreateOneWithoutReportInput
  comments: ReportCommentCreateManyWithoutReportInput
  status: StatusCreateOneInput!
  type: ReportTypeCreateOneInput!
  deadline: DateTime
}

input ReportCreateManyWithoutCreatorInput {
  create: [ReportCreateWithoutCreatorInput!]
  connect: [ReportWhereUniqueInput!]
}

input ReportCreateOneWithoutCloserInput {
  create: ReportCreateWithoutCloserInput
  connect: ReportWhereUniqueInput
}

input ReportCreateOneWithoutCommentsInput {
  create: ReportCreateWithoutCommentsInput
  connect: ReportWhereUniqueInput
}

input ReportCreateWithoutCloserInput {
  image: String!
  lat: Float!
  lng: Float!
  creator: PeopleCreateOneWithoutReportsInput!
  comments: ReportCommentCreateManyWithoutReportInput
  status: StatusCreateOneInput!
  type: ReportTypeCreateOneInput!
  deadline: DateTime
}

input ReportCreateWithoutCommentsInput {
  image: String!
  lat: Float!
  lng: Float!
  creator: PeopleCreateOneWithoutReportsInput!
  closer: CloserCreateOneWithoutReportInput
  status: StatusCreateOneInput!
  type: ReportTypeCreateOneInput!
  deadline: DateTime
}

input ReportCreateWithoutCreatorInput {
  image: String!
  lat: Float!
  lng: Float!
  closer: CloserCreateOneWithoutReportInput
  comments: ReportCommentCreateManyWithoutReportInput
  status: StatusCreateOneInput!
  type: ReportTypeCreateOneInput!
  deadline: DateTime
}

type ReportEdge {
  node: Report!
  cursor: String!
}

enum ReportOrderByInput {
  id_ASC
  id_DESC
  image_ASC
  image_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  deadline_ASC
  deadline_DESC
  createdAt_ASC
  createdAt_DESC
}

type ReportPreviousValues {
  id: Int!
  image: String!
  lat: Float!
  lng: Float!
  deadline: DateTime
  createdAt: DateTime!
}

input ReportScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  deadline: DateTime
  deadline_not: DateTime
  deadline_in: [DateTime!]
  deadline_not_in: [DateTime!]
  deadline_lt: DateTime
  deadline_lte: DateTime
  deadline_gt: DateTime
  deadline_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ReportScalarWhereInput!]
  OR: [ReportScalarWhereInput!]
  NOT: [ReportScalarWhereInput!]
}

type ReportSubscriptionPayload {
  mutation: MutationType!
  node: Report
  updatedFields: [String!]
  previousValues: ReportPreviousValues
}

input ReportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportWhereInput
  AND: [ReportSubscriptionWhereInput!]
  OR: [ReportSubscriptionWhereInput!]
  NOT: [ReportSubscriptionWhereInput!]
}

type ReportType {
  id: ID!
  name_uz: String!
  name_ru: String!
  name_en: String!
}

type ReportTypeConnection {
  pageInfo: PageInfo!
  edges: [ReportTypeEdge]!
  aggregate: AggregateReportType!
}

input ReportTypeCreateInput {
  id: ID
  name_uz: String!
  name_ru: String!
  name_en: String!
}

input ReportTypeCreateOneInput {
  create: ReportTypeCreateInput
  connect: ReportTypeWhereUniqueInput
}

type ReportTypeEdge {
  node: ReportType!
  cursor: String!
}

enum ReportTypeOrderByInput {
  id_ASC
  id_DESC
  name_uz_ASC
  name_uz_DESC
  name_ru_ASC
  name_ru_DESC
  name_en_ASC
  name_en_DESC
}

type ReportTypePreviousValues {
  id: ID!
  name_uz: String!
  name_ru: String!
  name_en: String!
}

type ReportTypeSubscriptionPayload {
  mutation: MutationType!
  node: ReportType
  updatedFields: [String!]
  previousValues: ReportTypePreviousValues
}

input ReportTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportTypeWhereInput
  AND: [ReportTypeSubscriptionWhereInput!]
  OR: [ReportTypeSubscriptionWhereInput!]
  NOT: [ReportTypeSubscriptionWhereInput!]
}

input ReportTypeUpdateDataInput {
  name_uz: String
  name_ru: String
  name_en: String
}

input ReportTypeUpdateInput {
  name_uz: String
  name_ru: String
  name_en: String
}

input ReportTypeUpdateManyMutationInput {
  name_uz: String
  name_ru: String
  name_en: String
}

input ReportTypeUpdateOneRequiredInput {
  create: ReportTypeCreateInput
  update: ReportTypeUpdateDataInput
  upsert: ReportTypeUpsertNestedInput
  connect: ReportTypeWhereUniqueInput
}

input ReportTypeUpsertNestedInput {
  update: ReportTypeUpdateDataInput!
  create: ReportTypeCreateInput!
}

input ReportTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name_uz: String
  name_uz_not: String
  name_uz_in: [String!]
  name_uz_not_in: [String!]
  name_uz_lt: String
  name_uz_lte: String
  name_uz_gt: String
  name_uz_gte: String
  name_uz_contains: String
  name_uz_not_contains: String
  name_uz_starts_with: String
  name_uz_not_starts_with: String
  name_uz_ends_with: String
  name_uz_not_ends_with: String
  name_ru: String
  name_ru_not: String
  name_ru_in: [String!]
  name_ru_not_in: [String!]
  name_ru_lt: String
  name_ru_lte: String
  name_ru_gt: String
  name_ru_gte: String
  name_ru_contains: String
  name_ru_not_contains: String
  name_ru_starts_with: String
  name_ru_not_starts_with: String
  name_ru_ends_with: String
  name_ru_not_ends_with: String
  name_en: String
  name_en_not: String
  name_en_in: [String!]
  name_en_not_in: [String!]
  name_en_lt: String
  name_en_lte: String
  name_en_gt: String
  name_en_gte: String
  name_en_contains: String
  name_en_not_contains: String
  name_en_starts_with: String
  name_en_not_starts_with: String
  name_en_ends_with: String
  name_en_not_ends_with: String
  AND: [ReportTypeWhereInput!]
  OR: [ReportTypeWhereInput!]
  NOT: [ReportTypeWhereInput!]
}

input ReportTypeWhereUniqueInput {
  id: ID
}

input ReportUpdateInput {
  image: String
  lat: Float
  lng: Float
  creator: PeopleUpdateOneRequiredWithoutReportsInput
  closer: CloserUpdateOneWithoutReportInput
  comments: ReportCommentUpdateManyWithoutReportInput
  status: StatusUpdateOneRequiredInput
  type: ReportTypeUpdateOneRequiredInput
  deadline: DateTime
}

input ReportUpdateManyDataInput {
  image: String
  lat: Float
  lng: Float
  deadline: DateTime
}

input ReportUpdateManyMutationInput {
  image: String
  lat: Float
  lng: Float
  deadline: DateTime
}

input ReportUpdateManyWithoutCreatorInput {
  create: [ReportCreateWithoutCreatorInput!]
  delete: [ReportWhereUniqueInput!]
  connect: [ReportWhereUniqueInput!]
  set: [ReportWhereUniqueInput!]
  disconnect: [ReportWhereUniqueInput!]
  update: [ReportUpdateWithWhereUniqueWithoutCreatorInput!]
  upsert: [ReportUpsertWithWhereUniqueWithoutCreatorInput!]
  deleteMany: [ReportScalarWhereInput!]
  updateMany: [ReportUpdateManyWithWhereNestedInput!]
}

input ReportUpdateManyWithWhereNestedInput {
  where: ReportScalarWhereInput!
  data: ReportUpdateManyDataInput!
}

input ReportUpdateOneRequiredWithoutCloserInput {
  create: ReportCreateWithoutCloserInput
  update: ReportUpdateWithoutCloserDataInput
  upsert: ReportUpsertWithoutCloserInput
  connect: ReportWhereUniqueInput
}

input ReportUpdateOneRequiredWithoutCommentsInput {
  create: ReportCreateWithoutCommentsInput
  update: ReportUpdateWithoutCommentsDataInput
  upsert: ReportUpsertWithoutCommentsInput
  connect: ReportWhereUniqueInput
}

input ReportUpdateWithoutCloserDataInput {
  image: String
  lat: Float
  lng: Float
  creator: PeopleUpdateOneRequiredWithoutReportsInput
  comments: ReportCommentUpdateManyWithoutReportInput
  status: StatusUpdateOneRequiredInput
  type: ReportTypeUpdateOneRequiredInput
  deadline: DateTime
}

input ReportUpdateWithoutCommentsDataInput {
  image: String
  lat: Float
  lng: Float
  creator: PeopleUpdateOneRequiredWithoutReportsInput
  closer: CloserUpdateOneWithoutReportInput
  status: StatusUpdateOneRequiredInput
  type: ReportTypeUpdateOneRequiredInput
  deadline: DateTime
}

input ReportUpdateWithoutCreatorDataInput {
  image: String
  lat: Float
  lng: Float
  closer: CloserUpdateOneWithoutReportInput
  comments: ReportCommentUpdateManyWithoutReportInput
  status: StatusUpdateOneRequiredInput
  type: ReportTypeUpdateOneRequiredInput
  deadline: DateTime
}

input ReportUpdateWithWhereUniqueWithoutCreatorInput {
  where: ReportWhereUniqueInput!
  data: ReportUpdateWithoutCreatorDataInput!
}

input ReportUpsertWithoutCloserInput {
  update: ReportUpdateWithoutCloserDataInput!
  create: ReportCreateWithoutCloserInput!
}

input ReportUpsertWithoutCommentsInput {
  update: ReportUpdateWithoutCommentsDataInput!
  create: ReportCreateWithoutCommentsInput!
}

input ReportUpsertWithWhereUniqueWithoutCreatorInput {
  where: ReportWhereUniqueInput!
  update: ReportUpdateWithoutCreatorDataInput!
  create: ReportCreateWithoutCreatorInput!
}

input ReportWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  creator: PeopleWhereInput
  closer: CloserWhereInput
  comments_every: ReportCommentWhereInput
  comments_some: ReportCommentWhereInput
  comments_none: ReportCommentWhereInput
  status: StatusWhereInput
  type: ReportTypeWhereInput
  deadline: DateTime
  deadline_not: DateTime
  deadline_in: [DateTime!]
  deadline_not_in: [DateTime!]
  deadline_lt: DateTime
  deadline_lte: DateTime
  deadline_gt: DateTime
  deadline_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ReportWhereInput!]
  OR: [ReportWhereInput!]
  NOT: [ReportWhereInput!]
}

input ReportWhereUniqueInput {
  id: Int
}

type Role {
  id: ID!
  name: String!
}

type RoleConnection {
  pageInfo: PageInfo!
  edges: [RoleEdge]!
  aggregate: AggregateRole!
}

input RoleCreateInput {
  id: ID
  name: String!
}

input RoleCreateOneInput {
  create: RoleCreateInput
  connect: RoleWhereUniqueInput
}

type RoleEdge {
  node: Role!
  cursor: String!
}

enum RoleOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type RolePreviousValues {
  id: ID!
  name: String!
}

type RoleSubscriptionPayload {
  mutation: MutationType!
  node: Role
  updatedFields: [String!]
  previousValues: RolePreviousValues
}

input RoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoleWhereInput
  AND: [RoleSubscriptionWhereInput!]
  OR: [RoleSubscriptionWhereInput!]
  NOT: [RoleSubscriptionWhereInput!]
}

input RoleUpdateDataInput {
  name: String
}

input RoleUpdateInput {
  name: String
}

input RoleUpdateManyMutationInput {
  name: String
}

input RoleUpdateOneRequiredInput {
  create: RoleCreateInput
  update: RoleUpdateDataInput
  upsert: RoleUpsertNestedInput
  connect: RoleWhereUniqueInput
}

input RoleUpsertNestedInput {
  update: RoleUpdateDataInput!
  create: RoleCreateInput!
}

input RoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
}

input RoleWhereUniqueInput {
  id: ID
}

type Status {
  id: ID!
  name: String!
}

type StatusConnection {
  pageInfo: PageInfo!
  edges: [StatusEdge]!
  aggregate: AggregateStatus!
}

input StatusCreateInput {
  id: ID
  name: String!
}

input StatusCreateOneInput {
  create: StatusCreateInput
  connect: StatusWhereUniqueInput
}

type StatusEdge {
  node: Status!
  cursor: String!
}

enum StatusOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type StatusPreviousValues {
  id: ID!
  name: String!
}

type StatusSubscriptionPayload {
  mutation: MutationType!
  node: Status
  updatedFields: [String!]
  previousValues: StatusPreviousValues
}

input StatusSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StatusWhereInput
  AND: [StatusSubscriptionWhereInput!]
  OR: [StatusSubscriptionWhereInput!]
  NOT: [StatusSubscriptionWhereInput!]
}

input StatusUpdateDataInput {
  name: String
}

input StatusUpdateInput {
  name: String
}

input StatusUpdateManyMutationInput {
  name: String
}

input StatusUpdateOneRequiredInput {
  create: StatusCreateInput
  update: StatusUpdateDataInput
  upsert: StatusUpsertNestedInput
  connect: StatusWhereUniqueInput
}

input StatusUpsertNestedInput {
  update: StatusUpdateDataInput!
  create: StatusCreateInput!
}

input StatusWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [StatusWhereInput!]
  OR: [StatusWhereInput!]
  NOT: [StatusWhereInput!]
}

input StatusWhereUniqueInput {
  id: ID
}

type Subscription {
  closer(where: CloserSubscriptionWhereInput): CloserSubscriptionPayload
  people(where: PeopleSubscriptionWhereInput): PeopleSubscriptionPayload
  report(where: ReportSubscriptionWhereInput): ReportSubscriptionPayload
  reportComment(where: ReportCommentSubscriptionWhereInput): ReportCommentSubscriptionPayload
  reportType(where: ReportTypeSubscriptionWhereInput): ReportTypeSubscriptionPayload
  role(where: RoleSubscriptionWhereInput): RoleSubscriptionPayload
  status(where: StatusSubscriptionWhereInput): StatusSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  phone: String!
  username: String!
  password: String!
  image: String!
  role: Role!
  employees(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  manager: User
  reports(where: ReportCommentWhereInput, orderBy: ReportCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ReportComment!]
  closedReports(where: CloserWhereInput, orderBy: CloserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Closer!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  phone: String!
  username: String!
  password: String!
  image: String!
  role: RoleCreateOneInput!
  employees: UserCreateManyWithoutManagerInput
  manager: UserCreateOneWithoutEmployeesInput
  reports: ReportCommentCreateManyWithoutToInput
  closedReports: CloserCreateManyWithoutUserInput
}

input UserCreateManyWithoutManagerInput {
  create: [UserCreateWithoutManagerInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneWithoutClosedReportsInput {
  create: UserCreateWithoutClosedReportsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutEmployeesInput {
  create: UserCreateWithoutEmployeesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutReportsInput {
  create: UserCreateWithoutReportsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutClosedReportsInput {
  id: ID
  name: String!
  phone: String!
  username: String!
  password: String!
  image: String!
  role: RoleCreateOneInput!
  employees: UserCreateManyWithoutManagerInput
  manager: UserCreateOneWithoutEmployeesInput
  reports: ReportCommentCreateManyWithoutToInput
}

input UserCreateWithoutEmployeesInput {
  id: ID
  name: String!
  phone: String!
  username: String!
  password: String!
  image: String!
  role: RoleCreateOneInput!
  manager: UserCreateOneWithoutEmployeesInput
  reports: ReportCommentCreateManyWithoutToInput
  closedReports: CloserCreateManyWithoutUserInput
}

input UserCreateWithoutManagerInput {
  id: ID
  name: String!
  phone: String!
  username: String!
  password: String!
  image: String!
  role: RoleCreateOneInput!
  employees: UserCreateManyWithoutManagerInput
  reports: ReportCommentCreateManyWithoutToInput
  closedReports: CloserCreateManyWithoutUserInput
}

input UserCreateWithoutReportsInput {
  id: ID
  name: String!
  phone: String!
  username: String!
  password: String!
  image: String!
  role: RoleCreateOneInput!
  employees: UserCreateManyWithoutManagerInput
  manager: UserCreateOneWithoutEmployeesInput
  closedReports: CloserCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  image_ASC
  image_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  phone: String!
  username: String!
  password: String!
  image: String!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  phone: String
  username: String
  password: String
  image: String
  role: RoleUpdateOneRequiredInput
  employees: UserUpdateManyWithoutManagerInput
  manager: UserUpdateOneWithoutEmployeesInput
  reports: ReportCommentUpdateManyWithoutToInput
  closedReports: CloserUpdateManyWithoutUserInput
}

input UserUpdateManyDataInput {
  name: String
  phone: String
  username: String
  password: String
  image: String
}

input UserUpdateManyMutationInput {
  name: String
  phone: String
  username: String
  password: String
  image: String
}

input UserUpdateManyWithoutManagerInput {
  create: [UserCreateWithoutManagerInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutManagerInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutManagerInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredWithoutClosedReportsInput {
  create: UserCreateWithoutClosedReportsInput
  update: UserUpdateWithoutClosedReportsDataInput
  upsert: UserUpsertWithoutClosedReportsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutReportsInput {
  create: UserCreateWithoutReportsInput
  update: UserUpdateWithoutReportsDataInput
  upsert: UserUpsertWithoutReportsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutEmployeesInput {
  create: UserCreateWithoutEmployeesInput
  update: UserUpdateWithoutEmployeesDataInput
  upsert: UserUpsertWithoutEmployeesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutClosedReportsDataInput {
  name: String
  phone: String
  username: String
  password: String
  image: String
  role: RoleUpdateOneRequiredInput
  employees: UserUpdateManyWithoutManagerInput
  manager: UserUpdateOneWithoutEmployeesInput
  reports: ReportCommentUpdateManyWithoutToInput
}

input UserUpdateWithoutEmployeesDataInput {
  name: String
  phone: String
  username: String
  password: String
  image: String
  role: RoleUpdateOneRequiredInput
  manager: UserUpdateOneWithoutEmployeesInput
  reports: ReportCommentUpdateManyWithoutToInput
  closedReports: CloserUpdateManyWithoutUserInput
}

input UserUpdateWithoutManagerDataInput {
  name: String
  phone: String
  username: String
  password: String
  image: String
  role: RoleUpdateOneRequiredInput
  employees: UserUpdateManyWithoutManagerInput
  reports: ReportCommentUpdateManyWithoutToInput
  closedReports: CloserUpdateManyWithoutUserInput
}

input UserUpdateWithoutReportsDataInput {
  name: String
  phone: String
  username: String
  password: String
  image: String
  role: RoleUpdateOneRequiredInput
  employees: UserUpdateManyWithoutManagerInput
  manager: UserUpdateOneWithoutEmployeesInput
  closedReports: CloserUpdateManyWithoutUserInput
}

input UserUpdateWithWhereUniqueWithoutManagerInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutManagerDataInput!
}

input UserUpsertWithoutClosedReportsInput {
  update: UserUpdateWithoutClosedReportsDataInput!
  create: UserCreateWithoutClosedReportsInput!
}

input UserUpsertWithoutEmployeesInput {
  update: UserUpdateWithoutEmployeesDataInput!
  create: UserCreateWithoutEmployeesInput!
}

input UserUpsertWithoutReportsInput {
  update: UserUpdateWithoutReportsDataInput!
  create: UserCreateWithoutReportsInput!
}

input UserUpsertWithWhereUniqueWithoutManagerInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutManagerDataInput!
  create: UserCreateWithoutManagerInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  role: RoleWhereInput
  employees_every: UserWhereInput
  employees_some: UserWhereInput
  employees_none: UserWhereInput
  manager: UserWhereInput
  reports_every: ReportCommentWhereInput
  reports_some: ReportCommentWhereInput
  reports_none: ReportCommentWhereInput
  closedReports_every: CloserWhereInput
  closedReports_some: CloserWhereInput
  closedReports_none: CloserWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    