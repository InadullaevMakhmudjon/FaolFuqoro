// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  closer: (where?: CloserWhereInput) => Promise<boolean>;
  people: (where?: PeopleWhereInput) => Promise<boolean>;
  report: (where?: ReportWhereInput) => Promise<boolean>;
  reportComment: (where?: ReportCommentWhereInput) => Promise<boolean>;
  reportType: (where?: ReportTypeWhereInput) => Promise<boolean>;
  role: (where?: RoleWhereInput) => Promise<boolean>;
  status: (where?: StatusWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  closer: (where: CloserWhereUniqueInput) => CloserNullablePromise;
  closers: (args?: {
    where?: CloserWhereInput;
    orderBy?: CloserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Closer>;
  closersConnection: (args?: {
    where?: CloserWhereInput;
    orderBy?: CloserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CloserConnectionPromise;
  people: (where: PeopleWhereUniqueInput) => PeopleNullablePromise;
  peoples: (args?: {
    where?: PeopleWhereInput;
    orderBy?: PeopleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<People>;
  peoplesConnection: (args?: {
    where?: PeopleWhereInput;
    orderBy?: PeopleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PeopleConnectionPromise;
  report: (where: ReportWhereUniqueInput) => ReportNullablePromise;
  reports: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Report>;
  reportsConnection: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReportConnectionPromise;
  reportComment: (
    where: ReportCommentWhereUniqueInput
  ) => ReportCommentNullablePromise;
  reportComments: (args?: {
    where?: ReportCommentWhereInput;
    orderBy?: ReportCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ReportComment>;
  reportCommentsConnection: (args?: {
    where?: ReportCommentWhereInput;
    orderBy?: ReportCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReportCommentConnectionPromise;
  reportType: (where: ReportTypeWhereUniqueInput) => ReportTypeNullablePromise;
  reportTypes: (args?: {
    where?: ReportTypeWhereInput;
    orderBy?: ReportTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ReportType>;
  reportTypesConnection: (args?: {
    where?: ReportTypeWhereInput;
    orderBy?: ReportTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReportTypeConnectionPromise;
  role: (where: RoleWhereUniqueInput) => RoleNullablePromise;
  roles: (args?: {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Role>;
  rolesConnection: (args?: {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoleConnectionPromise;
  status: (where: StatusWhereUniqueInput) => StatusNullablePromise;
  statuses: (args?: {
    where?: StatusWhereInput;
    orderBy?: StatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Status>;
  statusesConnection: (args?: {
    where?: StatusWhereInput;
    orderBy?: StatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StatusConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCloser: (data: CloserCreateInput) => CloserPromise;
  updateCloser: (args: {
    data: CloserUpdateInput;
    where: CloserWhereUniqueInput;
  }) => CloserPromise;
  updateManyClosers: (args: {
    data: CloserUpdateManyMutationInput;
    where?: CloserWhereInput;
  }) => BatchPayloadPromise;
  upsertCloser: (args: {
    where: CloserWhereUniqueInput;
    create: CloserCreateInput;
    update: CloserUpdateInput;
  }) => CloserPromise;
  deleteCloser: (where: CloserWhereUniqueInput) => CloserPromise;
  deleteManyClosers: (where?: CloserWhereInput) => BatchPayloadPromise;
  createPeople: (data: PeopleCreateInput) => PeoplePromise;
  updatePeople: (args: {
    data: PeopleUpdateInput;
    where: PeopleWhereUniqueInput;
  }) => PeoplePromise;
  updateManyPeoples: (args: {
    data: PeopleUpdateManyMutationInput;
    where?: PeopleWhereInput;
  }) => BatchPayloadPromise;
  upsertPeople: (args: {
    where: PeopleWhereUniqueInput;
    create: PeopleCreateInput;
    update: PeopleUpdateInput;
  }) => PeoplePromise;
  deletePeople: (where: PeopleWhereUniqueInput) => PeoplePromise;
  deleteManyPeoples: (where?: PeopleWhereInput) => BatchPayloadPromise;
  createReport: (data: ReportCreateInput) => ReportPromise;
  updateReport: (args: {
    data: ReportUpdateInput;
    where: ReportWhereUniqueInput;
  }) => ReportPromise;
  updateManyReports: (args: {
    data: ReportUpdateManyMutationInput;
    where?: ReportWhereInput;
  }) => BatchPayloadPromise;
  upsertReport: (args: {
    where: ReportWhereUniqueInput;
    create: ReportCreateInput;
    update: ReportUpdateInput;
  }) => ReportPromise;
  deleteReport: (where: ReportWhereUniqueInput) => ReportPromise;
  deleteManyReports: (where?: ReportWhereInput) => BatchPayloadPromise;
  createReportComment: (data: ReportCommentCreateInput) => ReportCommentPromise;
  updateReportComment: (args: {
    data: ReportCommentUpdateInput;
    where: ReportCommentWhereUniqueInput;
  }) => ReportCommentPromise;
  updateManyReportComments: (args: {
    data: ReportCommentUpdateManyMutationInput;
    where?: ReportCommentWhereInput;
  }) => BatchPayloadPromise;
  upsertReportComment: (args: {
    where: ReportCommentWhereUniqueInput;
    create: ReportCommentCreateInput;
    update: ReportCommentUpdateInput;
  }) => ReportCommentPromise;
  deleteReportComment: (
    where: ReportCommentWhereUniqueInput
  ) => ReportCommentPromise;
  deleteManyReportComments: (
    where?: ReportCommentWhereInput
  ) => BatchPayloadPromise;
  createReportType: (data: ReportTypeCreateInput) => ReportTypePromise;
  updateReportType: (args: {
    data: ReportTypeUpdateInput;
    where: ReportTypeWhereUniqueInput;
  }) => ReportTypePromise;
  updateManyReportTypes: (args: {
    data: ReportTypeUpdateManyMutationInput;
    where?: ReportTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertReportType: (args: {
    where: ReportTypeWhereUniqueInput;
    create: ReportTypeCreateInput;
    update: ReportTypeUpdateInput;
  }) => ReportTypePromise;
  deleteReportType: (where: ReportTypeWhereUniqueInput) => ReportTypePromise;
  deleteManyReportTypes: (where?: ReportTypeWhereInput) => BatchPayloadPromise;
  createRole: (data: RoleCreateInput) => RolePromise;
  updateRole: (args: {
    data: RoleUpdateInput;
    where: RoleWhereUniqueInput;
  }) => RolePromise;
  updateManyRoles: (args: {
    data: RoleUpdateManyMutationInput;
    where?: RoleWhereInput;
  }) => BatchPayloadPromise;
  upsertRole: (args: {
    where: RoleWhereUniqueInput;
    create: RoleCreateInput;
    update: RoleUpdateInput;
  }) => RolePromise;
  deleteRole: (where: RoleWhereUniqueInput) => RolePromise;
  deleteManyRoles: (where?: RoleWhereInput) => BatchPayloadPromise;
  createStatus: (data: StatusCreateInput) => StatusPromise;
  updateStatus: (args: {
    data: StatusUpdateInput;
    where: StatusWhereUniqueInput;
  }) => StatusPromise;
  updateManyStatuses: (args: {
    data: StatusUpdateManyMutationInput;
    where?: StatusWhereInput;
  }) => BatchPayloadPromise;
  upsertStatus: (args: {
    where: StatusWhereUniqueInput;
    create: StatusCreateInput;
    update: StatusUpdateInput;
  }) => StatusPromise;
  deleteStatus: (where: StatusWhereUniqueInput) => StatusPromise;
  deleteManyStatuses: (where?: StatusWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  closer: (
    where?: CloserSubscriptionWhereInput
  ) => CloserSubscriptionPayloadSubscription;
  people: (
    where?: PeopleSubscriptionWhereInput
  ) => PeopleSubscriptionPayloadSubscription;
  report: (
    where?: ReportSubscriptionWhereInput
  ) => ReportSubscriptionPayloadSubscription;
  reportComment: (
    where?: ReportCommentSubscriptionWhereInput
  ) => ReportCommentSubscriptionPayloadSubscription;
  reportType: (
    where?: ReportTypeSubscriptionWhereInput
  ) => ReportTypeSubscriptionPayloadSubscription;
  role: (
    where?: RoleSubscriptionWhereInput
  ) => RoleSubscriptionPayloadSubscription;
  status: (
    where?: StatusSubscriptionWhereInput
  ) => StatusSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "image_ASC"
  | "image_DESC";

export type ReportCommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "comment_ASC"
  | "comment_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ReportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "image_ASC"
  | "image_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "deadline_ASC"
  | "deadline_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CloserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type PeopleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "password_ASC"
  | "password_DESC"
  | "image_ASC"
  | "image_DESC";

export type ReportTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type RoleOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type StatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CloserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  role?: Maybe<RoleWhereInput>;
  employees_every?: Maybe<UserWhereInput>;
  employees_some?: Maybe<UserWhereInput>;
  employees_none?: Maybe<UserWhereInput>;
  manager?: Maybe<UserWhereInput>;
  reports_every?: Maybe<ReportCommentWhereInput>;
  reports_some?: Maybe<ReportCommentWhereInput>;
  reports_none?: Maybe<ReportCommentWhereInput>;
  closedReports_every?: Maybe<CloserWhereInput>;
  closedReports_some?: Maybe<CloserWhereInput>;
  closedReports_none?: Maybe<CloserWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface RoleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<RoleWhereInput[] | RoleWhereInput>;
  OR?: Maybe<RoleWhereInput[] | RoleWhereInput>;
  NOT?: Maybe<RoleWhereInput[] | RoleWhereInput>;
}

export interface ReportCommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  status?: Maybe<StatusWhereInput>;
  report?: Maybe<ReportWhereInput>;
  to?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportCommentWhereInput[] | ReportCommentWhereInput>;
  OR?: Maybe<ReportCommentWhereInput[] | ReportCommentWhereInput>;
  NOT?: Maybe<ReportCommentWhereInput[] | ReportCommentWhereInput>;
}

export interface StatusWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<StatusWhereInput[] | StatusWhereInput>;
  OR?: Maybe<StatusWhereInput[] | StatusWhereInput>;
  NOT?: Maybe<StatusWhereInput[] | StatusWhereInput>;
}

export interface ReportWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  creator?: Maybe<PeopleWhereInput>;
  closer?: Maybe<CloserWhereInput>;
  comments_every?: Maybe<ReportCommentWhereInput>;
  comments_some?: Maybe<ReportCommentWhereInput>;
  comments_none?: Maybe<ReportCommentWhereInput>;
  status?: Maybe<StatusWhereInput>;
  type?: Maybe<ReportTypeWhereInput>;
  deadline?: Maybe<DateTimeInput>;
  deadline_not?: Maybe<DateTimeInput>;
  deadline_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deadline_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deadline_lt?: Maybe<DateTimeInput>;
  deadline_lte?: Maybe<DateTimeInput>;
  deadline_gt?: Maybe<DateTimeInput>;
  deadline_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  OR?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  NOT?: Maybe<ReportWhereInput[] | ReportWhereInput>;
}

export interface PeopleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  reports_every?: Maybe<ReportWhereInput>;
  reports_some?: Maybe<ReportWhereInput>;
  reports_none?: Maybe<ReportWhereInput>;
  AND?: Maybe<PeopleWhereInput[] | PeopleWhereInput>;
  OR?: Maybe<PeopleWhereInput[] | PeopleWhereInput>;
  NOT?: Maybe<PeopleWhereInput[] | PeopleWhereInput>;
}

export interface CloserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  report?: Maybe<ReportWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CloserWhereInput[] | CloserWhereInput>;
  OR?: Maybe<CloserWhereInput[] | CloserWhereInput>;
  NOT?: Maybe<CloserWhereInput[] | CloserWhereInput>;
}

export interface ReportTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ReportTypeWhereInput[] | ReportTypeWhereInput>;
  OR?: Maybe<ReportTypeWhereInput[] | ReportTypeWhereInput>;
  NOT?: Maybe<ReportTypeWhereInput[] | ReportTypeWhereInput>;
}

export type PeopleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  phone?: Maybe<String>;
}>;

export type ReportWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type ReportCommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ReportTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type StatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CloserCreateInput {
  id?: Maybe<ID_Input>;
  image: String;
  user: UserCreateOneWithoutClosedReportsInput;
  report: ReportCreateOneWithoutCloserInput;
}

export interface UserCreateOneWithoutClosedReportsInput {
  create?: Maybe<UserCreateWithoutClosedReportsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutClosedReportsInput {
  id?: Maybe<ID_Input>;
  name: String;
  phone: String;
  username: String;
  password: String;
  image: String;
  role: RoleCreateOneInput;
  employees?: Maybe<UserCreateManyWithoutManagerInput>;
  manager?: Maybe<UserCreateOneWithoutEmployeesInput>;
  reports?: Maybe<ReportCommentCreateManyWithoutToInput>;
}

export interface RoleCreateOneInput {
  create?: Maybe<RoleCreateInput>;
  connect?: Maybe<RoleWhereUniqueInput>;
}

export interface RoleCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface UserCreateManyWithoutManagerInput {
  create?: Maybe<
    UserCreateWithoutManagerInput[] | UserCreateWithoutManagerInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutManagerInput {
  id?: Maybe<ID_Input>;
  name: String;
  phone: String;
  username: String;
  password: String;
  image: String;
  role: RoleCreateOneInput;
  employees?: Maybe<UserCreateManyWithoutManagerInput>;
  reports?: Maybe<ReportCommentCreateManyWithoutToInput>;
  closedReports?: Maybe<CloserCreateManyWithoutUserInput>;
}

export interface ReportCommentCreateManyWithoutToInput {
  create?: Maybe<
    ReportCommentCreateWithoutToInput[] | ReportCommentCreateWithoutToInput
  >;
  connect?: Maybe<
    ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput
  >;
}

export interface ReportCommentCreateWithoutToInput {
  id?: Maybe<ID_Input>;
  comment?: Maybe<String>;
  status: StatusCreateOneInput;
  report: ReportCreateOneWithoutCommentsInput;
}

export interface StatusCreateOneInput {
  create?: Maybe<StatusCreateInput>;
  connect?: Maybe<StatusWhereUniqueInput>;
}

export interface StatusCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ReportCreateOneWithoutCommentsInput {
  create?: Maybe<ReportCreateWithoutCommentsInput>;
  connect?: Maybe<ReportWhereUniqueInput>;
}

export interface ReportCreateWithoutCommentsInput {
  image: String;
  lat: Float;
  lng: Float;
  creator: PeopleCreateOneWithoutReportsInput;
  closer?: Maybe<CloserCreateOneWithoutReportInput>;
  status: StatusCreateOneInput;
  type: ReportTypeCreateOneInput;
  deadline?: Maybe<DateTimeInput>;
}

export interface PeopleCreateOneWithoutReportsInput {
  create?: Maybe<PeopleCreateWithoutReportsInput>;
  connect?: Maybe<PeopleWhereUniqueInput>;
}

export interface PeopleCreateWithoutReportsInput {
  id?: Maybe<ID_Input>;
  name: String;
  phone: String;
  password: String;
  image: String;
}

export interface CloserCreateOneWithoutReportInput {
  create?: Maybe<CloserCreateWithoutReportInput>;
  connect?: Maybe<CloserWhereUniqueInput>;
}

export interface CloserCreateWithoutReportInput {
  id?: Maybe<ID_Input>;
  image: String;
  user: UserCreateOneWithoutClosedReportsInput;
}

export interface ReportTypeCreateOneInput {
  create?: Maybe<ReportTypeCreateInput>;
  connect?: Maybe<ReportTypeWhereUniqueInput>;
}

export interface ReportTypeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface CloserCreateManyWithoutUserInput {
  create?: Maybe<CloserCreateWithoutUserInput[] | CloserCreateWithoutUserInput>;
  connect?: Maybe<CloserWhereUniqueInput[] | CloserWhereUniqueInput>;
}

export interface CloserCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  image: String;
  report: ReportCreateOneWithoutCloserInput;
}

export interface ReportCreateOneWithoutCloserInput {
  create?: Maybe<ReportCreateWithoutCloserInput>;
  connect?: Maybe<ReportWhereUniqueInput>;
}

export interface ReportCreateWithoutCloserInput {
  image: String;
  lat: Float;
  lng: Float;
  creator: PeopleCreateOneWithoutReportsInput;
  comments?: Maybe<ReportCommentCreateManyWithoutReportInput>;
  status: StatusCreateOneInput;
  type: ReportTypeCreateOneInput;
  deadline?: Maybe<DateTimeInput>;
}

export interface ReportCommentCreateManyWithoutReportInput {
  create?: Maybe<
    | ReportCommentCreateWithoutReportInput[]
    | ReportCommentCreateWithoutReportInput
  >;
  connect?: Maybe<
    ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput
  >;
}

export interface ReportCommentCreateWithoutReportInput {
  id?: Maybe<ID_Input>;
  comment?: Maybe<String>;
  status: StatusCreateOneInput;
  to: UserCreateOneWithoutReportsInput;
}

export interface UserCreateOneWithoutReportsInput {
  create?: Maybe<UserCreateWithoutReportsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutReportsInput {
  id?: Maybe<ID_Input>;
  name: String;
  phone: String;
  username: String;
  password: String;
  image: String;
  role: RoleCreateOneInput;
  employees?: Maybe<UserCreateManyWithoutManagerInput>;
  manager?: Maybe<UserCreateOneWithoutEmployeesInput>;
  closedReports?: Maybe<CloserCreateManyWithoutUserInput>;
}

export interface UserCreateOneWithoutEmployeesInput {
  create?: Maybe<UserCreateWithoutEmployeesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEmployeesInput {
  id?: Maybe<ID_Input>;
  name: String;
  phone: String;
  username: String;
  password: String;
  image: String;
  role: RoleCreateOneInput;
  manager?: Maybe<UserCreateOneWithoutEmployeesInput>;
  reports?: Maybe<ReportCommentCreateManyWithoutToInput>;
  closedReports?: Maybe<CloserCreateManyWithoutUserInput>;
}

export interface CloserUpdateInput {
  image?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutClosedReportsInput>;
  report?: Maybe<ReportUpdateOneRequiredWithoutCloserInput>;
}

export interface UserUpdateOneRequiredWithoutClosedReportsInput {
  create?: Maybe<UserCreateWithoutClosedReportsInput>;
  update?: Maybe<UserUpdateWithoutClosedReportsDataInput>;
  upsert?: Maybe<UserUpsertWithoutClosedReportsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutClosedReportsDataInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
  role?: Maybe<RoleUpdateOneRequiredInput>;
  employees?: Maybe<UserUpdateManyWithoutManagerInput>;
  manager?: Maybe<UserUpdateOneWithoutEmployeesInput>;
  reports?: Maybe<ReportCommentUpdateManyWithoutToInput>;
}

export interface RoleUpdateOneRequiredInput {
  create?: Maybe<RoleCreateInput>;
  update?: Maybe<RoleUpdateDataInput>;
  upsert?: Maybe<RoleUpsertNestedInput>;
  connect?: Maybe<RoleWhereUniqueInput>;
}

export interface RoleUpdateDataInput {
  name?: Maybe<String>;
}

export interface RoleUpsertNestedInput {
  update: RoleUpdateDataInput;
  create: RoleCreateInput;
}

export interface UserUpdateManyWithoutManagerInput {
  create?: Maybe<
    UserCreateWithoutManagerInput[] | UserCreateWithoutManagerInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutManagerInput[]
    | UserUpdateWithWhereUniqueWithoutManagerInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutManagerInput[]
    | UserUpsertWithWhereUniqueWithoutManagerInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutManagerInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutManagerDataInput;
}

export interface UserUpdateWithoutManagerDataInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
  role?: Maybe<RoleUpdateOneRequiredInput>;
  employees?: Maybe<UserUpdateManyWithoutManagerInput>;
  reports?: Maybe<ReportCommentUpdateManyWithoutToInput>;
  closedReports?: Maybe<CloserUpdateManyWithoutUserInput>;
}

export interface ReportCommentUpdateManyWithoutToInput {
  create?: Maybe<
    ReportCommentCreateWithoutToInput[] | ReportCommentCreateWithoutToInput
  >;
  delete?: Maybe<
    ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput
  >;
  connect?: Maybe<
    ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput
  >;
  set?: Maybe<ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput>;
  disconnect?: Maybe<
    ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput
  >;
  update?: Maybe<
    | ReportCommentUpdateWithWhereUniqueWithoutToInput[]
    | ReportCommentUpdateWithWhereUniqueWithoutToInput
  >;
  upsert?: Maybe<
    | ReportCommentUpsertWithWhereUniqueWithoutToInput[]
    | ReportCommentUpsertWithWhereUniqueWithoutToInput
  >;
  deleteMany?: Maybe<
    ReportCommentScalarWhereInput[] | ReportCommentScalarWhereInput
  >;
  updateMany?: Maybe<
    | ReportCommentUpdateManyWithWhereNestedInput[]
    | ReportCommentUpdateManyWithWhereNestedInput
  >;
}

export interface ReportCommentUpdateWithWhereUniqueWithoutToInput {
  where: ReportCommentWhereUniqueInput;
  data: ReportCommentUpdateWithoutToDataInput;
}

export interface ReportCommentUpdateWithoutToDataInput {
  comment?: Maybe<String>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  report?: Maybe<ReportUpdateOneRequiredWithoutCommentsInput>;
}

export interface StatusUpdateOneRequiredInput {
  create?: Maybe<StatusCreateInput>;
  update?: Maybe<StatusUpdateDataInput>;
  upsert?: Maybe<StatusUpsertNestedInput>;
  connect?: Maybe<StatusWhereUniqueInput>;
}

export interface StatusUpdateDataInput {
  name?: Maybe<String>;
}

export interface StatusUpsertNestedInput {
  update: StatusUpdateDataInput;
  create: StatusCreateInput;
}

export interface ReportUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<ReportCreateWithoutCommentsInput>;
  update?: Maybe<ReportUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<ReportUpsertWithoutCommentsInput>;
  connect?: Maybe<ReportWhereUniqueInput>;
}

export interface ReportUpdateWithoutCommentsDataInput {
  image?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  creator?: Maybe<PeopleUpdateOneRequiredWithoutReportsInput>;
  closer?: Maybe<CloserUpdateOneWithoutReportInput>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  type?: Maybe<ReportTypeUpdateOneRequiredInput>;
  deadline?: Maybe<DateTimeInput>;
}

export interface PeopleUpdateOneRequiredWithoutReportsInput {
  create?: Maybe<PeopleCreateWithoutReportsInput>;
  update?: Maybe<PeopleUpdateWithoutReportsDataInput>;
  upsert?: Maybe<PeopleUpsertWithoutReportsInput>;
  connect?: Maybe<PeopleWhereUniqueInput>;
}

export interface PeopleUpdateWithoutReportsDataInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
}

export interface PeopleUpsertWithoutReportsInput {
  update: PeopleUpdateWithoutReportsDataInput;
  create: PeopleCreateWithoutReportsInput;
}

export interface CloserUpdateOneWithoutReportInput {
  create?: Maybe<CloserCreateWithoutReportInput>;
  update?: Maybe<CloserUpdateWithoutReportDataInput>;
  upsert?: Maybe<CloserUpsertWithoutReportInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CloserWhereUniqueInput>;
}

export interface CloserUpdateWithoutReportDataInput {
  image?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutClosedReportsInput>;
}

export interface CloserUpsertWithoutReportInput {
  update: CloserUpdateWithoutReportDataInput;
  create: CloserCreateWithoutReportInput;
}

export interface ReportTypeUpdateOneRequiredInput {
  create?: Maybe<ReportTypeCreateInput>;
  update?: Maybe<ReportTypeUpdateDataInput>;
  upsert?: Maybe<ReportTypeUpsertNestedInput>;
  connect?: Maybe<ReportTypeWhereUniqueInput>;
}

export interface ReportTypeUpdateDataInput {
  name?: Maybe<String>;
}

export interface ReportTypeUpsertNestedInput {
  update: ReportTypeUpdateDataInput;
  create: ReportTypeCreateInput;
}

export interface ReportUpsertWithoutCommentsInput {
  update: ReportUpdateWithoutCommentsDataInput;
  create: ReportCreateWithoutCommentsInput;
}

export interface ReportCommentUpsertWithWhereUniqueWithoutToInput {
  where: ReportCommentWhereUniqueInput;
  update: ReportCommentUpdateWithoutToDataInput;
  create: ReportCommentCreateWithoutToInput;
}

export interface ReportCommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportCommentScalarWhereInput[] | ReportCommentScalarWhereInput>;
  OR?: Maybe<ReportCommentScalarWhereInput[] | ReportCommentScalarWhereInput>;
  NOT?: Maybe<ReportCommentScalarWhereInput[] | ReportCommentScalarWhereInput>;
}

export interface ReportCommentUpdateManyWithWhereNestedInput {
  where: ReportCommentScalarWhereInput;
  data: ReportCommentUpdateManyDataInput;
}

export interface ReportCommentUpdateManyDataInput {
  comment?: Maybe<String>;
}

export interface CloserUpdateManyWithoutUserInput {
  create?: Maybe<CloserCreateWithoutUserInput[] | CloserCreateWithoutUserInput>;
  delete?: Maybe<CloserWhereUniqueInput[] | CloserWhereUniqueInput>;
  connect?: Maybe<CloserWhereUniqueInput[] | CloserWhereUniqueInput>;
  set?: Maybe<CloserWhereUniqueInput[] | CloserWhereUniqueInput>;
  disconnect?: Maybe<CloserWhereUniqueInput[] | CloserWhereUniqueInput>;
  update?: Maybe<
    | CloserUpdateWithWhereUniqueWithoutUserInput[]
    | CloserUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CloserUpsertWithWhereUniqueWithoutUserInput[]
    | CloserUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<CloserScalarWhereInput[] | CloserScalarWhereInput>;
  updateMany?: Maybe<
    | CloserUpdateManyWithWhereNestedInput[]
    | CloserUpdateManyWithWhereNestedInput
  >;
}

export interface CloserUpdateWithWhereUniqueWithoutUserInput {
  where: CloserWhereUniqueInput;
  data: CloserUpdateWithoutUserDataInput;
}

export interface CloserUpdateWithoutUserDataInput {
  image?: Maybe<String>;
  report?: Maybe<ReportUpdateOneRequiredWithoutCloserInput>;
}

export interface ReportUpdateOneRequiredWithoutCloserInput {
  create?: Maybe<ReportCreateWithoutCloserInput>;
  update?: Maybe<ReportUpdateWithoutCloserDataInput>;
  upsert?: Maybe<ReportUpsertWithoutCloserInput>;
  connect?: Maybe<ReportWhereUniqueInput>;
}

export interface ReportUpdateWithoutCloserDataInput {
  image?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  creator?: Maybe<PeopleUpdateOneRequiredWithoutReportsInput>;
  comments?: Maybe<ReportCommentUpdateManyWithoutReportInput>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  type?: Maybe<ReportTypeUpdateOneRequiredInput>;
  deadline?: Maybe<DateTimeInput>;
}

export interface ReportCommentUpdateManyWithoutReportInput {
  create?: Maybe<
    | ReportCommentCreateWithoutReportInput[]
    | ReportCommentCreateWithoutReportInput
  >;
  delete?: Maybe<
    ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput
  >;
  connect?: Maybe<
    ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput
  >;
  set?: Maybe<ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput>;
  disconnect?: Maybe<
    ReportCommentWhereUniqueInput[] | ReportCommentWhereUniqueInput
  >;
  update?: Maybe<
    | ReportCommentUpdateWithWhereUniqueWithoutReportInput[]
    | ReportCommentUpdateWithWhereUniqueWithoutReportInput
  >;
  upsert?: Maybe<
    | ReportCommentUpsertWithWhereUniqueWithoutReportInput[]
    | ReportCommentUpsertWithWhereUniqueWithoutReportInput
  >;
  deleteMany?: Maybe<
    ReportCommentScalarWhereInput[] | ReportCommentScalarWhereInput
  >;
  updateMany?: Maybe<
    | ReportCommentUpdateManyWithWhereNestedInput[]
    | ReportCommentUpdateManyWithWhereNestedInput
  >;
}

export interface ReportCommentUpdateWithWhereUniqueWithoutReportInput {
  where: ReportCommentWhereUniqueInput;
  data: ReportCommentUpdateWithoutReportDataInput;
}

export interface ReportCommentUpdateWithoutReportDataInput {
  comment?: Maybe<String>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  to?: Maybe<UserUpdateOneRequiredWithoutReportsInput>;
}

export interface UserUpdateOneRequiredWithoutReportsInput {
  create?: Maybe<UserCreateWithoutReportsInput>;
  update?: Maybe<UserUpdateWithoutReportsDataInput>;
  upsert?: Maybe<UserUpsertWithoutReportsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutReportsDataInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
  role?: Maybe<RoleUpdateOneRequiredInput>;
  employees?: Maybe<UserUpdateManyWithoutManagerInput>;
  manager?: Maybe<UserUpdateOneWithoutEmployeesInput>;
  closedReports?: Maybe<CloserUpdateManyWithoutUserInput>;
}

export interface UserUpdateOneWithoutEmployeesInput {
  create?: Maybe<UserCreateWithoutEmployeesInput>;
  update?: Maybe<UserUpdateWithoutEmployeesDataInput>;
  upsert?: Maybe<UserUpsertWithoutEmployeesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEmployeesDataInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
  role?: Maybe<RoleUpdateOneRequiredInput>;
  manager?: Maybe<UserUpdateOneWithoutEmployeesInput>;
  reports?: Maybe<ReportCommentUpdateManyWithoutToInput>;
  closedReports?: Maybe<CloserUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutEmployeesInput {
  update: UserUpdateWithoutEmployeesDataInput;
  create: UserCreateWithoutEmployeesInput;
}

export interface UserUpsertWithoutReportsInput {
  update: UserUpdateWithoutReportsDataInput;
  create: UserCreateWithoutReportsInput;
}

export interface ReportCommentUpsertWithWhereUniqueWithoutReportInput {
  where: ReportCommentWhereUniqueInput;
  update: ReportCommentUpdateWithoutReportDataInput;
  create: ReportCommentCreateWithoutReportInput;
}

export interface ReportUpsertWithoutCloserInput {
  update: ReportUpdateWithoutCloserDataInput;
  create: ReportCreateWithoutCloserInput;
}

export interface CloserUpsertWithWhereUniqueWithoutUserInput {
  where: CloserWhereUniqueInput;
  update: CloserUpdateWithoutUserDataInput;
  create: CloserCreateWithoutUserInput;
}

export interface CloserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CloserScalarWhereInput[] | CloserScalarWhereInput>;
  OR?: Maybe<CloserScalarWhereInput[] | CloserScalarWhereInput>;
  NOT?: Maybe<CloserScalarWhereInput[] | CloserScalarWhereInput>;
}

export interface CloserUpdateManyWithWhereNestedInput {
  where: CloserScalarWhereInput;
  data: CloserUpdateManyDataInput;
}

export interface CloserUpdateManyDataInput {
  image?: Maybe<String>;
}

export interface UserUpsertWithWhereUniqueWithoutManagerInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutManagerDataInput;
  create: UserCreateWithoutManagerInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
}

export interface UserUpsertWithoutClosedReportsInput {
  update: UserUpdateWithoutClosedReportsDataInput;
  create: UserCreateWithoutClosedReportsInput;
}

export interface CloserUpdateManyMutationInput {
  image?: Maybe<String>;
}

export interface PeopleCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  phone: String;
  password: String;
  image: String;
  reports?: Maybe<ReportCreateManyWithoutCreatorInput>;
}

export interface ReportCreateManyWithoutCreatorInput {
  create?: Maybe<
    ReportCreateWithoutCreatorInput[] | ReportCreateWithoutCreatorInput
  >;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
}

export interface ReportCreateWithoutCreatorInput {
  image: String;
  lat: Float;
  lng: Float;
  closer?: Maybe<CloserCreateOneWithoutReportInput>;
  comments?: Maybe<ReportCommentCreateManyWithoutReportInput>;
  status: StatusCreateOneInput;
  type: ReportTypeCreateOneInput;
  deadline?: Maybe<DateTimeInput>;
}

export interface PeopleUpdateInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
  reports?: Maybe<ReportUpdateManyWithoutCreatorInput>;
}

export interface ReportUpdateManyWithoutCreatorInput {
  create?: Maybe<
    ReportCreateWithoutCreatorInput[] | ReportCreateWithoutCreatorInput
  >;
  delete?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  set?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  disconnect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  update?: Maybe<
    | ReportUpdateWithWhereUniqueWithoutCreatorInput[]
    | ReportUpdateWithWhereUniqueWithoutCreatorInput
  >;
  upsert?: Maybe<
    | ReportUpsertWithWhereUniqueWithoutCreatorInput[]
    | ReportUpsertWithWhereUniqueWithoutCreatorInput
  >;
  deleteMany?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  updateMany?: Maybe<
    | ReportUpdateManyWithWhereNestedInput[]
    | ReportUpdateManyWithWhereNestedInput
  >;
}

export interface ReportUpdateWithWhereUniqueWithoutCreatorInput {
  where: ReportWhereUniqueInput;
  data: ReportUpdateWithoutCreatorDataInput;
}

export interface ReportUpdateWithoutCreatorDataInput {
  image?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  closer?: Maybe<CloserUpdateOneWithoutReportInput>;
  comments?: Maybe<ReportCommentUpdateManyWithoutReportInput>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  type?: Maybe<ReportTypeUpdateOneRequiredInput>;
  deadline?: Maybe<DateTimeInput>;
}

export interface ReportUpsertWithWhereUniqueWithoutCreatorInput {
  where: ReportWhereUniqueInput;
  update: ReportUpdateWithoutCreatorDataInput;
  create: ReportCreateWithoutCreatorInput;
}

export interface ReportScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  deadline?: Maybe<DateTimeInput>;
  deadline_not?: Maybe<DateTimeInput>;
  deadline_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deadline_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deadline_lt?: Maybe<DateTimeInput>;
  deadline_lte?: Maybe<DateTimeInput>;
  deadline_gt?: Maybe<DateTimeInput>;
  deadline_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  OR?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  NOT?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
}

export interface ReportUpdateManyWithWhereNestedInput {
  where: ReportScalarWhereInput;
  data: ReportUpdateManyDataInput;
}

export interface ReportUpdateManyDataInput {
  image?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  deadline?: Maybe<DateTimeInput>;
}

export interface PeopleUpdateManyMutationInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
}

export interface ReportCreateInput {
  image: String;
  lat: Float;
  lng: Float;
  creator: PeopleCreateOneWithoutReportsInput;
  closer?: Maybe<CloserCreateOneWithoutReportInput>;
  comments?: Maybe<ReportCommentCreateManyWithoutReportInput>;
  status: StatusCreateOneInput;
  type: ReportTypeCreateOneInput;
  deadline?: Maybe<DateTimeInput>;
}

export interface ReportUpdateInput {
  image?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  creator?: Maybe<PeopleUpdateOneRequiredWithoutReportsInput>;
  closer?: Maybe<CloserUpdateOneWithoutReportInput>;
  comments?: Maybe<ReportCommentUpdateManyWithoutReportInput>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  type?: Maybe<ReportTypeUpdateOneRequiredInput>;
  deadline?: Maybe<DateTimeInput>;
}

export interface ReportUpdateManyMutationInput {
  image?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  deadline?: Maybe<DateTimeInput>;
}

export interface ReportCommentCreateInput {
  id?: Maybe<ID_Input>;
  comment?: Maybe<String>;
  status: StatusCreateOneInput;
  report: ReportCreateOneWithoutCommentsInput;
  to: UserCreateOneWithoutReportsInput;
}

export interface ReportCommentUpdateInput {
  comment?: Maybe<String>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  report?: Maybe<ReportUpdateOneRequiredWithoutCommentsInput>;
  to?: Maybe<UserUpdateOneRequiredWithoutReportsInput>;
}

export interface ReportCommentUpdateManyMutationInput {
  comment?: Maybe<String>;
}

export interface ReportTypeUpdateInput {
  name?: Maybe<String>;
}

export interface ReportTypeUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface RoleUpdateInput {
  name?: Maybe<String>;
}

export interface RoleUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface StatusUpdateInput {
  name?: Maybe<String>;
}

export interface StatusUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  phone: String;
  username: String;
  password: String;
  image: String;
  role: RoleCreateOneInput;
  employees?: Maybe<UserCreateManyWithoutManagerInput>;
  manager?: Maybe<UserCreateOneWithoutEmployeesInput>;
  reports?: Maybe<ReportCommentCreateManyWithoutToInput>;
  closedReports?: Maybe<CloserCreateManyWithoutUserInput>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
  role?: Maybe<RoleUpdateOneRequiredInput>;
  employees?: Maybe<UserUpdateManyWithoutManagerInput>;
  manager?: Maybe<UserUpdateOneWithoutEmployeesInput>;
  reports?: Maybe<ReportCommentUpdateManyWithoutToInput>;
  closedReports?: Maybe<CloserUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  image?: Maybe<String>;
}

export interface CloserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CloserWhereInput>;
  AND?: Maybe<CloserSubscriptionWhereInput[] | CloserSubscriptionWhereInput>;
  OR?: Maybe<CloserSubscriptionWhereInput[] | CloserSubscriptionWhereInput>;
  NOT?: Maybe<CloserSubscriptionWhereInput[] | CloserSubscriptionWhereInput>;
}

export interface PeopleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PeopleWhereInput>;
  AND?: Maybe<PeopleSubscriptionWhereInput[] | PeopleSubscriptionWhereInput>;
  OR?: Maybe<PeopleSubscriptionWhereInput[] | PeopleSubscriptionWhereInput>;
  NOT?: Maybe<PeopleSubscriptionWhereInput[] | PeopleSubscriptionWhereInput>;
}

export interface ReportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReportWhereInput>;
  AND?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  OR?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  NOT?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
}

export interface ReportCommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReportCommentWhereInput>;
  AND?: Maybe<
    ReportCommentSubscriptionWhereInput[] | ReportCommentSubscriptionWhereInput
  >;
  OR?: Maybe<
    ReportCommentSubscriptionWhereInput[] | ReportCommentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ReportCommentSubscriptionWhereInput[] | ReportCommentSubscriptionWhereInput
  >;
}

export interface ReportTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReportTypeWhereInput>;
  AND?: Maybe<
    ReportTypeSubscriptionWhereInput[] | ReportTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    ReportTypeSubscriptionWhereInput[] | ReportTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ReportTypeSubscriptionWhereInput[] | ReportTypeSubscriptionWhereInput
  >;
}

export interface RoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoleWhereInput>;
  AND?: Maybe<RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput>;
  OR?: Maybe<RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput>;
  NOT?: Maybe<RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput>;
}

export interface StatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StatusWhereInput>;
  AND?: Maybe<StatusSubscriptionWhereInput[] | StatusSubscriptionWhereInput>;
  OR?: Maybe<StatusSubscriptionWhereInput[] | StatusSubscriptionWhereInput>;
  NOT?: Maybe<StatusSubscriptionWhereInput[] | StatusSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Closer {
  id: ID_Output;
  image: String;
  createdAt: DateTimeOutput;
}

export interface CloserPromise extends Promise<Closer>, Fragmentable {
  id: () => Promise<ID_Output>;
  image: () => Promise<String>;
  user: <T = UserPromise>() => T;
  report: <T = ReportPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CloserSubscription
  extends Promise<AsyncIterator<Closer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  report: <T = ReportSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CloserNullablePromise
  extends Promise<Closer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image: () => Promise<String>;
  user: <T = UserPromise>() => T;
  report: <T = ReportPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  name: String;
  phone: String;
  username: String;
  password: String;
  image: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  image: () => Promise<String>;
  role: <T = RolePromise>() => T;
  employees: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  manager: <T = UserPromise>() => T;
  reports: <T = FragmentableArray<ReportComment>>(args?: {
    where?: ReportCommentWhereInput;
    orderBy?: ReportCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  closedReports: <T = FragmentableArray<Closer>>(args?: {
    where?: CloserWhereInput;
    orderBy?: CloserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  role: <T = RoleSubscription>() => T;
  employees: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  manager: <T = UserSubscription>() => T;
  reports: <T = Promise<AsyncIterator<ReportCommentSubscription>>>(args?: {
    where?: ReportCommentWhereInput;
    orderBy?: ReportCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  closedReports: <T = Promise<AsyncIterator<CloserSubscription>>>(args?: {
    where?: CloserWhereInput;
    orderBy?: CloserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  image: () => Promise<String>;
  role: <T = RolePromise>() => T;
  employees: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  manager: <T = UserPromise>() => T;
  reports: <T = FragmentableArray<ReportComment>>(args?: {
    where?: ReportCommentWhereInput;
    orderBy?: ReportCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  closedReports: <T = FragmentableArray<Closer>>(args?: {
    where?: CloserWhereInput;
    orderBy?: CloserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Role {
  id: ID_Output;
  name: String;
}

export interface RolePromise extends Promise<Role>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface RoleSubscription
  extends Promise<AsyncIterator<Role>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoleNullablePromise
  extends Promise<Role | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ReportComment {
  id: ID_Output;
  comment?: String;
  createdAt: DateTimeOutput;
}

export interface ReportCommentPromise
  extends Promise<ReportComment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comment: () => Promise<String>;
  status: <T = StatusPromise>() => T;
  report: <T = ReportPromise>() => T;
  to: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReportCommentSubscription
  extends Promise<AsyncIterator<ReportComment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  comment: () => Promise<AsyncIterator<String>>;
  status: <T = StatusSubscription>() => T;
  report: <T = ReportSubscription>() => T;
  to: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportCommentNullablePromise
  extends Promise<ReportComment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comment: () => Promise<String>;
  status: <T = StatusPromise>() => T;
  report: <T = ReportPromise>() => T;
  to: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Status {
  id: ID_Output;
  name: String;
}

export interface StatusPromise extends Promise<Status>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StatusSubscription
  extends Promise<AsyncIterator<Status>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StatusNullablePromise
  extends Promise<Status | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface Report {
  id: Int;
  image: String;
  lat: Float;
  lng: Float;
  deadline?: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ReportPromise extends Promise<Report>, Fragmentable {
  id: () => Promise<Int>;
  image: () => Promise<String>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  creator: <T = PeoplePromise>() => T;
  closer: <T = CloserPromise>() => T;
  comments: <T = FragmentableArray<ReportComment>>(args?: {
    where?: ReportCommentWhereInput;
    orderBy?: ReportCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: <T = StatusPromise>() => T;
  type: <T = ReportTypePromise>() => T;
  deadline: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReportSubscription
  extends Promise<AsyncIterator<Report>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  image: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  creator: <T = PeopleSubscription>() => T;
  closer: <T = CloserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<ReportCommentSubscription>>>(args?: {
    where?: ReportCommentWhereInput;
    orderBy?: ReportCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: <T = StatusSubscription>() => T;
  type: <T = ReportTypeSubscription>() => T;
  deadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportNullablePromise
  extends Promise<Report | null>,
    Fragmentable {
  id: () => Promise<Int>;
  image: () => Promise<String>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  creator: <T = PeoplePromise>() => T;
  closer: <T = CloserPromise>() => T;
  comments: <T = FragmentableArray<ReportComment>>(args?: {
    where?: ReportCommentWhereInput;
    orderBy?: ReportCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: <T = StatusPromise>() => T;
  type: <T = ReportTypePromise>() => T;
  deadline: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface People {
  id: ID_Output;
  name: String;
  phone: String;
  password: String;
  image: String;
}

export interface PeoplePromise extends Promise<People>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  image: () => Promise<String>;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PeopleSubscription
  extends Promise<AsyncIterator<People>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  reports: <T = Promise<AsyncIterator<ReportSubscription>>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PeopleNullablePromise
  extends Promise<People | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  image: () => Promise<String>;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ReportType {
  id: ID_Output;
  name: String;
}

export interface ReportTypePromise extends Promise<ReportType>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ReportTypeSubscription
  extends Promise<AsyncIterator<ReportType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ReportTypeNullablePromise
  extends Promise<ReportType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CloserConnection {
  pageInfo: PageInfo;
  edges: CloserEdge[];
}

export interface CloserConnectionPromise
  extends Promise<CloserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CloserEdge>>() => T;
  aggregate: <T = AggregateCloserPromise>() => T;
}

export interface CloserConnectionSubscription
  extends Promise<AsyncIterator<CloserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CloserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCloserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CloserEdge {
  node: Closer;
  cursor: String;
}

export interface CloserEdgePromise extends Promise<CloserEdge>, Fragmentable {
  node: <T = CloserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CloserEdgeSubscription
  extends Promise<AsyncIterator<CloserEdge>>,
    Fragmentable {
  node: <T = CloserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCloser {
  count: Int;
}

export interface AggregateCloserPromise
  extends Promise<AggregateCloser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCloserSubscription
  extends Promise<AsyncIterator<AggregateCloser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PeopleConnection {
  pageInfo: PageInfo;
  edges: PeopleEdge[];
}

export interface PeopleConnectionPromise
  extends Promise<PeopleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PeopleEdge>>() => T;
  aggregate: <T = AggregatePeoplePromise>() => T;
}

export interface PeopleConnectionSubscription
  extends Promise<AsyncIterator<PeopleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PeopleEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePeopleSubscription>() => T;
}

export interface PeopleEdge {
  node: People;
  cursor: String;
}

export interface PeopleEdgePromise extends Promise<PeopleEdge>, Fragmentable {
  node: <T = PeoplePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PeopleEdgeSubscription
  extends Promise<AsyncIterator<PeopleEdge>>,
    Fragmentable {
  node: <T = PeopleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePeople {
  count: Int;
}

export interface AggregatePeoplePromise
  extends Promise<AggregatePeople>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePeopleSubscription
  extends Promise<AsyncIterator<AggregatePeople>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReportConnection {
  pageInfo: PageInfo;
  edges: ReportEdge[];
}

export interface ReportConnectionPromise
  extends Promise<ReportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportEdge>>() => T;
  aggregate: <T = AggregateReportPromise>() => T;
}

export interface ReportConnectionSubscription
  extends Promise<AsyncIterator<ReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportSubscription>() => T;
}

export interface ReportEdge {
  node: Report;
  cursor: String;
}

export interface ReportEdgePromise extends Promise<ReportEdge>, Fragmentable {
  node: <T = ReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportEdgeSubscription
  extends Promise<AsyncIterator<ReportEdge>>,
    Fragmentable {
  node: <T = ReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReport {
  count: Int;
}

export interface AggregateReportPromise
  extends Promise<AggregateReport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportSubscription
  extends Promise<AsyncIterator<AggregateReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReportCommentConnection {
  pageInfo: PageInfo;
  edges: ReportCommentEdge[];
}

export interface ReportCommentConnectionPromise
  extends Promise<ReportCommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportCommentEdge>>() => T;
  aggregate: <T = AggregateReportCommentPromise>() => T;
}

export interface ReportCommentConnectionSubscription
  extends Promise<AsyncIterator<ReportCommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportCommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportCommentSubscription>() => T;
}

export interface ReportCommentEdge {
  node: ReportComment;
  cursor: String;
}

export interface ReportCommentEdgePromise
  extends Promise<ReportCommentEdge>,
    Fragmentable {
  node: <T = ReportCommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportCommentEdgeSubscription
  extends Promise<AsyncIterator<ReportCommentEdge>>,
    Fragmentable {
  node: <T = ReportCommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReportComment {
  count: Int;
}

export interface AggregateReportCommentPromise
  extends Promise<AggregateReportComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportCommentSubscription
  extends Promise<AsyncIterator<AggregateReportComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReportTypeConnection {
  pageInfo: PageInfo;
  edges: ReportTypeEdge[];
}

export interface ReportTypeConnectionPromise
  extends Promise<ReportTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportTypeEdge>>() => T;
  aggregate: <T = AggregateReportTypePromise>() => T;
}

export interface ReportTypeConnectionSubscription
  extends Promise<AsyncIterator<ReportTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportTypeSubscription>() => T;
}

export interface ReportTypeEdge {
  node: ReportType;
  cursor: String;
}

export interface ReportTypeEdgePromise
  extends Promise<ReportTypeEdge>,
    Fragmentable {
  node: <T = ReportTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportTypeEdgeSubscription
  extends Promise<AsyncIterator<ReportTypeEdge>>,
    Fragmentable {
  node: <T = ReportTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReportType {
  count: Int;
}

export interface AggregateReportTypePromise
  extends Promise<AggregateReportType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportTypeSubscription
  extends Promise<AsyncIterator<AggregateReportType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoleConnection {
  pageInfo: PageInfo;
  edges: RoleEdge[];
}

export interface RoleConnectionPromise
  extends Promise<RoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoleEdge>>() => T;
  aggregate: <T = AggregateRolePromise>() => T;
}

export interface RoleConnectionSubscription
  extends Promise<AsyncIterator<RoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoleSubscription>() => T;
}

export interface RoleEdge {
  node: Role;
  cursor: String;
}

export interface RoleEdgePromise extends Promise<RoleEdge>, Fragmentable {
  node: <T = RolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoleEdgeSubscription
  extends Promise<AsyncIterator<RoleEdge>>,
    Fragmentable {
  node: <T = RoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRole {
  count: Int;
}

export interface AggregateRolePromise
  extends Promise<AggregateRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoleSubscription
  extends Promise<AsyncIterator<AggregateRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StatusConnection {
  pageInfo: PageInfo;
  edges: StatusEdge[];
}

export interface StatusConnectionPromise
  extends Promise<StatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StatusEdge>>() => T;
  aggregate: <T = AggregateStatusPromise>() => T;
}

export interface StatusConnectionSubscription
  extends Promise<AsyncIterator<StatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStatusSubscription>() => T;
}

export interface StatusEdge {
  node: Status;
  cursor: String;
}

export interface StatusEdgePromise extends Promise<StatusEdge>, Fragmentable {
  node: <T = StatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StatusEdgeSubscription
  extends Promise<AsyncIterator<StatusEdge>>,
    Fragmentable {
  node: <T = StatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStatus {
  count: Int;
}

export interface AggregateStatusPromise
  extends Promise<AggregateStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStatusSubscription
  extends Promise<AsyncIterator<AggregateStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CloserSubscriptionPayload {
  mutation: MutationType;
  node: Closer;
  updatedFields: String[];
  previousValues: CloserPreviousValues;
}

export interface CloserSubscriptionPayloadPromise
  extends Promise<CloserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CloserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CloserPreviousValuesPromise>() => T;
}

export interface CloserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CloserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CloserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CloserPreviousValuesSubscription>() => T;
}

export interface CloserPreviousValues {
  id: ID_Output;
  image: String;
  createdAt: DateTimeOutput;
}

export interface CloserPreviousValuesPromise
  extends Promise<CloserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CloserPreviousValuesSubscription
  extends Promise<AsyncIterator<CloserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PeopleSubscriptionPayload {
  mutation: MutationType;
  node: People;
  updatedFields: String[];
  previousValues: PeoplePreviousValues;
}

export interface PeopleSubscriptionPayloadPromise
  extends Promise<PeopleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PeoplePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PeoplePreviousValuesPromise>() => T;
}

export interface PeopleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PeopleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PeopleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PeoplePreviousValuesSubscription>() => T;
}

export interface PeoplePreviousValues {
  id: ID_Output;
  name: String;
  phone: String;
  password: String;
  image: String;
}

export interface PeoplePreviousValuesPromise
  extends Promise<PeoplePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  image: () => Promise<String>;
}

export interface PeoplePreviousValuesSubscription
  extends Promise<AsyncIterator<PeoplePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface ReportSubscriptionPayload {
  mutation: MutationType;
  node: Report;
  updatedFields: String[];
  previousValues: ReportPreviousValues;
}

export interface ReportSubscriptionPayloadPromise
  extends Promise<ReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportPreviousValuesPromise>() => T;
}

export interface ReportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportPreviousValuesSubscription>() => T;
}

export interface ReportPreviousValues {
  id: Int;
  image: String;
  lat: Float;
  lng: Float;
  deadline?: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ReportPreviousValuesPromise
  extends Promise<ReportPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  image: () => Promise<String>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  deadline: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReportPreviousValuesSubscription
  extends Promise<AsyncIterator<ReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  image: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  deadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportCommentSubscriptionPayload {
  mutation: MutationType;
  node: ReportComment;
  updatedFields: String[];
  previousValues: ReportCommentPreviousValues;
}

export interface ReportCommentSubscriptionPayloadPromise
  extends Promise<ReportCommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportCommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportCommentPreviousValuesPromise>() => T;
}

export interface ReportCommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportCommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportCommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportCommentPreviousValuesSubscription>() => T;
}

export interface ReportCommentPreviousValues {
  id: ID_Output;
  comment?: String;
  createdAt: DateTimeOutput;
}

export interface ReportCommentPreviousValuesPromise
  extends Promise<ReportCommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comment: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReportCommentPreviousValuesSubscription
  extends Promise<AsyncIterator<ReportCommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  comment: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportTypeSubscriptionPayload {
  mutation: MutationType;
  node: ReportType;
  updatedFields: String[];
  previousValues: ReportTypePreviousValues;
}

export interface ReportTypeSubscriptionPayloadPromise
  extends Promise<ReportTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportTypePreviousValuesPromise>() => T;
}

export interface ReportTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportTypePreviousValuesSubscription>() => T;
}

export interface ReportTypePreviousValues {
  id: ID_Output;
  name: String;
}

export interface ReportTypePreviousValuesPromise
  extends Promise<ReportTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ReportTypePreviousValuesSubscription
  extends Promise<AsyncIterator<ReportTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoleSubscriptionPayload {
  mutation: MutationType;
  node: Role;
  updatedFields: String[];
  previousValues: RolePreviousValues;
}

export interface RoleSubscriptionPayloadPromise
  extends Promise<RoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RolePreviousValuesPromise>() => T;
}

export interface RoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RolePreviousValuesSubscription>() => T;
}

export interface RolePreviousValues {
  id: ID_Output;
  name: String;
}

export interface RolePreviousValuesPromise
  extends Promise<RolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface RolePreviousValuesSubscription
  extends Promise<AsyncIterator<RolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StatusSubscriptionPayload {
  mutation: MutationType;
  node: Status;
  updatedFields: String[];
  previousValues: StatusPreviousValues;
}

export interface StatusSubscriptionPayloadPromise
  extends Promise<StatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StatusPreviousValuesPromise>() => T;
}

export interface StatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StatusPreviousValuesSubscription>() => T;
}

export interface StatusPreviousValues {
  id: ID_Output;
  name: String;
}

export interface StatusPreviousValuesPromise
  extends Promise<StatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StatusPreviousValuesSubscription
  extends Promise<AsyncIterator<StatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  phone: String;
  username: String;
  password: String;
  image: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  image: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Status",
    embedded: false
  },
  {
    name: "People",
    embedded: false
  },
  {
    name: "ReportType",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Closer",
    embedded: false
  },
  {
    name: "Report",
    embedded: false
  },
  {
    name: "ReportComment",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
